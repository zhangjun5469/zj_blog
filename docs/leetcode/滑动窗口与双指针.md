> 参考：[滑动窗口与双指针](https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/owiz0j/)

# 循环不变量
## 概念解析
循环不变量」不是很高深的概念，在「算法」和「数据结构」的世界里，到处都有它的身影。

「循环不变量」是指我们在编写代码的过程中，**要一直循序不变的性质**，这样的性质是根据要解决的问题，由我们自己定义的。「循环不变量」是我们写对一个问题的基础，保证了在「初始化」「循环遍历」「结束」这三个阶段相同的性质，使得一个问题能够被正确解决。

## 例题
1. [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solutions/)。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int j = 1;
        // 循环不变量： [0,j) 区间不包含重复元素
        for(int i=1; i<n; ++i)
        {
            if(nums[i]!=nums[j-1])
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```

2. [最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/)。
```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int l=0, r=1;
        int ans = 1;
        // 循环不变量：[l,r) 区间为连续递增子序列
        while(r<n)
        {
            if(nums[r]<=nums[r-1])
            {
                l=r;
            }
            r++;
            ans = max(ans, r-l);
        }
        return ans;
    }
};
```

## 练习
1. [移除元素](https://leetcode.cn/problems/remove-element/solutions/)。
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int j=0;
        // 循环不变量：[0,j) 不含有 val 元素
        for(int i=0; i<n; ++i)
        {
            if(nums[i]!=val)
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```
2. [删除排序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solutions/)。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n<=2)
        {
            return n;
        }
        int j = 2;
        // 循环不变量：[0,j) 不含有出现次数超过两次的元素
        for(int i=2; i<n; ++i)
        {
            if(nums[i]!=nums[j-1] || nums[i]!=nums[j-2])
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```
3. [移动零](https://leetcode.cn/problems/move-zeroes/solutions/)。
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int j = 0;
        // 循环不变量： [0,j) 区间不含有0元素
        for(int i=0; i<n; ++i)
        {
            if(nums[i]!=0)
            {
                swap(nums[j], nums[i]);
                j++;
            }
        }
    }
};
```

# 使用循环不变量写对代码
## 关键概念
我们在写代码的时候一定要明确自己对变量以及区间的定义是什么，并且在编写代码的过程中保持定义不变。

## 例题
1. [颜色分类](https://leetcode.cn/problems/sort-colors/solutions/)。
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int zero = 0;
        int two = n;
        int i=0;
        // 循环不变量：
        // [0,zero) 区间是0
        // [zero, i) 区间是1
        // [two, n) 区间是2
        // [i,two) 区间待扫描
        while(i<two)
        {
            if(nums[i]==0)
            {
                swap(nums[zero], nums[i]);
                zero++;
                i++;
            }
            else if(nums[i]==1)
            {
                i++;
            }
            else
            {
                two--;
                swap(nums[two], nums[i]);
            }
        }
    }
};
```
2. [数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/)
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        int wantIdx = n-k;
        int l=0, r=n-1;
        while(true)
        {
            int partitionIdx = partition(nums, l, r);
            if(partitionIdx==wantIdx)
            {
                return nums[wantIdx];
            }
            else if(partitionIdx>wantIdx)
            {
                r = partitionIdx -1;
            }
            else
            {
                l = partitionIdx +1;
            }
        }
    }

    int partition(vector<int>& nums, int l, int r)
    {
        int pivot = nums[r];
        int j = l;
        int i = l;
        // 循环不变量： [l,j) 区间元素都小于等于pivot
        while(i<r)
        {
            if(nums[i]<=pivot)
            {
                swap(nums[j], nums[i]);
                j++;
            }
            i++;
        }
        swap(nums[j], nums[r]);
        return j;
    }
};
```

# 滑动窗口 1：同向交替移动的两个变量
## 概念解析
有一类数组上的问题，问我们固定长度的滑动窗口的性质，这一类问题在思维层面上相对简单。我们通过两道简单的例题向大家展示这一类问题的写法。

## 例题
1. [子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/solutions/)
```cpp
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int n = nums.size();
        int windowSum = 0;
        for(int i=0; i<k; ++i)
        {
            windowSum += nums[i];
        }
        int maxSum = windowSum;
        for(int i=k; i<n; ++i)
        {
            windowSum += nums[i] - nums[i-k];
            maxSum = max(maxSum, windowSum);
        }

        return (double)maxSum / k;
    }
};
```


2. [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/solutions/)
```cpp
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int n = customers.size();
        int originalCount = 0;
        for(int i=0; i<n; ++i)
        {
            if(grumpy[i]==0)
            {
                originalCount += customers[i];
            }
        }
        int extraCount = 0;
        for(int i=0; i<minutes; ++i)
        {
            if(grumpy[i]==1)
            {
                extraCount += customers[i];
            }
        }
        int maxExtraCount = extraCount;
        for(int i=minutes; i<n; ++i)
        {
            extraCount += (grumpy[i]==1? customers[i]:0) - (grumpy[i-minutes]==1? customers[i-minutes]:0);
            maxExtraCount = max(maxExtraCount, extraCount);
        }

        return originalCount + maxExtraCount;
    }
};
```

## 练习

3. [可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/)
```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int total = accumulate(cardPoints.begin(), cardPoints.end(), 0);
        int newK = n-k;
        int windowSum = 0;
        for(int i=0; i<newK; ++i)
        {
            windowSum += cardPoints[i];
        }
        int minSum = windowSum;
        for(int i=newK; i<n; ++i)
        {
            windowSum += cardPoints[i] - cardPoints[i-newK];
            minSum = min(minSum, windowSum);
        }

        return total - minSum;
    }
};
```

2. [定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/)
```cpp
class Solution {
public:
    int maxVowels(string s, int k) {
        int n = s.size();
        int windowSum = 0;
        for(int i=0; i<k; ++i)
        {
            if(check(s[i]))
            {
                windowSum++;
            }
        }
        int maxSum = windowSum;
        for(int i=k; i<n; ++i)
        {
            windowSum += (check(s[i])? 1:0) - (check(s[i-k])? 1:0);
            maxSum = max(maxSum, windowSum);
        }

        return maxSum;
    }

    bool check(char& c)
    {
        return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';
    }
};
```

3. [将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solutions/)
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int n = nums.size();
        int target = accumulate(nums.begin(), nums.end(), 0) - x;
        if(target==0)
        {
            return n;
        }
        int windowSum = 0;
        int l=0, r=0;
        int maxLen = 0;
        while(r<n)
        {
            windowSum += nums[r];
            r++;
            while(l<r && windowSum>target)
            {
                windowSum -= nums[l];
                l++;
            }
            if(target==windowSum)
            {
                maxLen = max(maxLen, r-l);
            }
        }

        return maxLen==0? -1 : (n-maxLen);
    }
};
```

# 滑动窗口 2：不定长度的滑动窗口
## 概念解析
有一类数组上的问题，需要使用两个指针变量（我们称为左指针和右指针），同向、交替向右移动完成任务。这样的过程像极了一个窗口在平面上滑动的过程，因此我们将解决这一类问题的算法称为「滑动窗口」问题。

## 例题

1. [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/solutions/)
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        int sn = s.size();
        int tn = t.size();
        vector<int> pattern(128, 0);
        int distance = 0;
        for(auto& c: t)
        {
            pattern[c]++;
            if(pattern[c]==1)
            {
                distance++;
            }
        }
        vector<int> window(128, 0);
        int matches = 0;
        int l=0, r=0;
        int start = 0;
        int minLen = sn+1;
        while(r<sn)
        {
            char c = s[r];
            window[c]++;
            if(window[c]==pattern[c])
            {
                matches++;
            }
            r++;
            while(matches==distance)
            {
                if(minLen > r-l)
                {
                    start = l;
                    minLen = r-l;
                }
                char lc = s[l];
                window[lc]--;
                if(window[lc]<pattern[lc])
                {
                    matches--;
                }
                l++;
            }
        }

        return minLen==sn+1? "" : s.substr(start, minLen);
    }
};
```

2. [替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/)
```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        int n = s.size();
        vector<int> charCount(26, 0);
        int l=0, r=0;
        int maxCount = 0;
        int maxLen = 0;
        // 循环过程中不需要维护 maxCount的正确性，只需要保证 charCount的正确性即可，仔细思考下(因为我们想求的是最大长度)。
        while(r<n)
        {
            charCount[s[r]-'A']++;
            maxCount = max(maxCount, charCount[s[r]-'A']);
            r++;
            while(r-l > maxCount+k)
            {
                charCount[s[l]-'A']--;
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```

## 基础练习

1. [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/)
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int maxLen = 0;
        int l=0,r=0;
        vector<int> charCount(128, 0);

        while(r<n)
        {
            charCount[s[r]]++;
            while(charCount[s[r]]>1)
            {
                charCount[s[l]]--;
                l++;
            }
            r++;
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```

2. [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/)
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int minLen = n+1;
        int windowSum =0;
        int l=0, r=0;
        
        while(r<n)
        {
            windowSum += nums[r];
            r++;
            while(windowSum>=target)
            {
                minLen = min(minLen, r-l);
                windowSum -= nums[l];
                l++;
            }
        }

        return minLen==n+1? 0:minLen;
    }
};
```

3. [删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/solutions/)
```cpp
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        unordered_map<int, int> countMap;
        int l=0, r=0;
        int windowSum = 0;

        while(r<n)
        {
            countMap[nums[r]]++;
            windowSum += nums[r];
            while(countMap[nums[r]]>1)
            {
                countMap[nums[l]]--;
                windowSum -= nums[l];
                l++;
            }
            r++;
            ans = max(ans, windowSum);
        }
        return ans;
    }
};
```

4. [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/)
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int sn = s.size();
        int pn = p.size();
        vector<int> pattern(26, 0);
        for(auto& c: p)
        {
            pattern[c-'a']++;
        }
        vector<int> ans;
        vector<int> charCount(26, 0);
        int l=0, r=0;
        
        while(r<sn)
        {
            charCount[s[r]-'a']++;
            while(charCount[s[r]-'a'] > pattern[s[r]-'a'])
            {
                charCount[s[l]-'a']--;
                l++;
            }
            r++;
            if(r-l==pn)
            {
                ans.push_back(l);
            }
        }

        return ans;
    }
};
```
5. [字符串的排列](https://leetcode.cn/problems/permutation-in-string/solutions/)
```cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n1 = s1.size();
        int n2 = s2.size();
        vector<int> pattern(26, 0);
        for(auto& c: s1)
        {
            pattern[c-'a']++;
        }
        vector<int> charCount(26, 0);
        int l=0, r=0;

        while(r<n2)
        {
            charCount[s2[r]-'a']++;
            while(charCount[s2[r]-'a'] > pattern[s2[r]-'a'])
            {
                charCount[s2[l]-'a']--;
                l++;
            }
            r++;
            if(r-l==n1)
            {
                return true;
            }
        }

        return false;
    }
};
```
6. [最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/solutions/)
```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int n = nums.size();
        int maxLen = 0;
        int windowSum = 0;
        int l=0, r=0;
        
        while(r<n)
        {
            windowSum += nums[r];
            r++;
            while(r-l > windowSum+1)
            {
                windowSum -= nums[l];
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```
7. [最大连续 1 的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/)
```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        int maxLen = 0;
        int windowSum = 0;
        int l=0, r=0;

        while(r<n)
        {
            windowSum += nums[r];
            r++;
            while(r-l > windowSum+k)
            {
                windowSum -= nums[l];
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```
8. [尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/)
```cpp
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        int n = s.size();
        int maxLen = 0;
        int windowCost = 0;
        int l=0, r=0;

        while(r<n)
        {
            windowCost += abs(t[r]-s[r]);
            r++;
            while(windowCost>maxCost)
            {
                windowCost -= abs(t[l]-s[l]);
                l++;
            }
            maxLen = max(maxLen, r-l);
        }
        return maxLen;
    }
};
```
9. [删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/solutions/)
```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int windowSum = 0;
        int l=0, r=0;
        int maxLen = 0;
        
        while(r<n)
        {
            windowSum += nums[r];
            r++;
            while(r-l > windowSum+1)
            {
                windowSum -= nums[l];
                l++;
            }
            maxLen = max(maxLen, r-l-1);
        }
        return maxLen;
    }
};
```
10. [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/solutions/)
```cpp
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int n = customers.size();
        int originalCount = 0;
        for(int i=0; i<n; ++i)
        {
            if(grumpy[i]==0)
            {
                originalCount += customers[i];
            }
        }
        int extraCount = 0;
        for(int i=0; i<minutes; ++i)
        {
            if(grumpy[i]==1)
            {
                extraCount += customers[i];
            }
        }
        int maxExtraCount = extraCount;
        for(int i=minutes; i<n; ++i)
        {
            extraCount += (grumpy[i]==1? customers[i]:0) - (grumpy[i-minutes]==1? customers[i-minutes]:0);
            maxExtraCount = max(maxExtraCount, extraCount);
        }

        return originalCount + maxExtraCount;
    }
};
```
11. [最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/solutions/)
```cpp
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        int n = arr.size();
        if(n<=1)
        {
            return n;
        }
        int maxLen = arr[1]!=arr[0]? 2 : 1;
        int l=0, r=2;

        while(r<n)
        {
            if((long)(arr[r]-arr[r-1])*(arr[r-1]-arr[r-2]) >= 0)
            {
                l = r-1;
            }
            r++;
            if(arr[r-1]!=arr[r-2])
            {
                maxLen = max(maxLen, r-l);
            }
        }
        return maxLen;
    }
};
```

# 滑动窗口 3：计数问题选讲
## 重要观点
写对计数问题的标准是：不重不漏。

我一般在计数区间个数时，以右端点为基准。

## 例题
1. [至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solutions/)
```cpp
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int n = s.size();
        vector<int> charCount(128, 0);
        int distinctCount = 0;
        int l=0, r=0;
        int maxLen = 0;
        
        while(r<n)
        {
            charCount[s[r]]++;
            if(charCount[s[r]]==1)
            {
                distinctCount++;
            }
            r++;
            while(distinctCount>2)
            {
                charCount[s[l]]--;
                if(charCount[s[l]]==0)
                {
                    distinctCount--;
                }
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```
2. [至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/solutions/)
```cpp
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        int n = s.size();
        int maxLen = 0;
        vector<int> charCount(128, 0);
        int distinctCount = 0;
        int l=0, r=0;

        while(r<n)
        {
            charCount[s[r]]++;
            if(charCount[s[r]]==1)
            {
                distinctCount++;
            }
            r++;
            while(distinctCount>k)
            {
                charCount[s[l]]--;
                if(charCount[s[l]]==0)
                {
                    distinctCount--;
                }
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```
3. [区间子数组个数](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/solutions/)
```cpp
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        return atMost(nums, right) - atMost(nums, left-1);
    }

    int atMost(vector<int>& nums, int k)
    {
        int n = nums.size();
        int ans = 0;
        int l=0, r=0;

        while(r<n)
        {
            if(nums[r]>k)
            {
                l=r+1;
            }
            r++;
            ans += r-l;
        }

        return ans;
    }
};
```
4. [K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/solutions/)
```cpp
class Solution {
public:
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return atMost(nums, k) - atMost(nums, k-1);
    }

    int atMost(vector<int>& nums, int k)
    {
        int n = nums.size();
        int ans = 0;
        unordered_map<int, int> countMap;
        int distinctCount = 0;
        int l=0, r=0;

        while(r<n)
        {
            countMap[nums[r]]++;
            if(countMap[nums[r]]==1)
            {
                distinctCount++;
            }
            r++;
            while(distinctCount>k)
            {
                countMap[nums[l]]--;
                if(countMap[nums[l]]==0)
                {
                    distinctCount--;
                }
                l++;
            }
            ans += r-l;
        }

        return ans;
    }
};
```
## 练习
1. [乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/solutions/)
```cpp
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int n = nums.size();
        int ans = 0;
        int l=0, r=0;
        int product = 1;

        while(r<n)
        {
            product *= nums[r];
            r++;
            while(l<r && product>=k)
            {
                product /= nums[l];
                l++;
            }
            ans += r-l;
        }

        return ans;
    }
};
```
2. [水果成篮](https://leetcode.cn/problems/fruit-into-baskets/solutions/)
```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int n = fruits.size();
        int maxLen = 0;
        unordered_map<int, int> countMap;
        int distinctCount = 0;
        int l=0, r=0;

        while(r<n)
        {
            countMap[fruits[r]]++;
            if(countMap[fruits[r]]==1)
            {
                distinctCount++;
            }
            r++;
            while(distinctCount>2)
            {
                countMap[fruits[l]]--;
                if(countMap[fruits[l]]==0)
                {
                    distinctCount--;
                }
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;

    }
};
```
3. [包含所有三种字符的子字符串数目](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/solutions/)
```cpp
class Solution {
public:
    int numberOfSubstrings(string s) {
        return atMost(s, 3) - atMost(s, 2);
    }

    int atMost(string& s, int k)
    {
        int n = s.size();
        vector<int> charCount(3, 0);
        int distinctCount = 0;
        int l=0, r=0;
        int ans = 0;

        while(r<n)
        {
            charCount[s[r]-'a']++;
            if(charCount[s[r]-'a']==1)
            {
                distinctCount++;
            }
            r++;
            while(distinctCount>k)
            {
                charCount[s[l]-'a']--;
                if(charCount[s[l]-'a']==0)
                {
                    distinctCount--;
                }
                l++;
            }
            ans += r-l;
        }
        return ans;
    }
};
```
4. [环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solutions/)
```cpp
class Solution {
public:
    int findSubstringInWraproundString(string s) {
        int n = s.size();
        int ans = 0;
        vector<int> rec(26, 0);
        int l=0, r=0;
        
        while(r<n)
        {
            if(r>0 && !isNext(s[r-1], s[r]))
            {
                l=r;
            }
            r++;
            rec[s[r-1]-'a'] = max(rec[s[r-1]-'a'], r-l);
        }

        return accumulate(rec.begin(), rec.end(), 0);
    }

    bool isNext(char a, char b)
    {
        return (b-'a') % 26 == ((a-'a') % 26 + 1) % 26;
    }
};
```
5. [找出第 k 小的距离对](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/solutions/)
```cpp
class Solution {
public:
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int left = 0, right = nums.back()-nums.front();

        while(left<right)
        {
            int mid = (left+right)>>1;
            if(check(nums, mid)>=k)
            {
                right = mid;
            }
            else
            {
                left = mid+1;
            }
        }
        return right;
    }

    // 距离对小于等于 x 的有多少个
    int check(vector<int>& nums, int x)
    {
        int n = nums.size();
        int ans = 0;
        int l=0, r=1;
        while(r<n)
        {
            while(nums[r]-nums[l]>x)
            {
                l++;
            }
            r++;
            ans += r-l-1;
        }
        return ans;
    }
};
```

# 滑动窗口 4：使用数据结构维护窗口性质
1. [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/solutions/)
```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans;
        deque<int> dq;
        for(int i=0; i<k; ++i)
        {
            while(!dq.empty() && nums[dq.back()]<=nums[i])
            {
                dq.pop_back();
            }
            dq.push_back(i);
        }
        ans.push_back(nums[dq.front()]);

        for(int i=k; i<n; ++i)
        {
            while(!dq.empty() && nums[dq.back()]<=nums[i])
            {
                dq.pop_back();
            }
            dq.push_back(i);
            while(!dq.empty() && dq.front()<=i-k)
            {
                dq.pop_front();
            }
            ans.push_back(nums[dq.front()]);
        }

        return ans;
    }
};
```

2. [滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/description/)
```cpp
class DualHeap
{
private:
    priority_queue<int> smallHeap;
    priority_queue<int, vector<int>, greater<int>> largeHeap;
    unordered_map<int, int> delayed;
    int k;
    int smallSize, largeSize;

    void makeBalance()
    {
        if(smallSize > largeSize+1)
        {
            largeHeap.push(smallHeap.top());
            smallHeap.pop();
            largeSize++;
            smallSize--;
            prune(smallHeap);
        }
        else if(largeSize > smallSize)
        {
            smallHeap.push(largeHeap.top());
            largeHeap.pop();
            smallSize++;
            largeSize--;
            prune(largeHeap);
        }
    }

    template<typename T>
    void prune(T& heap)
    {
        while(true)
        {
            int num = heap.top();
            if(delayed.count(num))
            {
                delayed[num]--;
                heap.pop();
                if(delayed[num]==0)
                {
                    delayed.erase(num);
                }
            }
            else
            {
                break;
            }
        }
    }
public:
    DualHeap(int k): k(k), smallSize(0), largeSize(0) {}
    void insert(int num)
    {
        if(smallSize==0 || num <= smallHeap.top())
        {
            smallHeap.push(num);
            smallSize++;
        }
        else
        {
            largeHeap.push(num);
            largeSize++;
        }
        makeBalance();
    }
    
    void erase(int num)
    {
        delayed[num]++;
        if(num <= smallHeap.top())
        {
            smallSize--;
            if(num==smallHeap.top())
            {
                prune(smallHeap);
            }
        }
        else
        {
            largeSize--;
            if(num==largeHeap.top())
            {
                prune(largeHeap);
            }
        }
        makeBalance();
    }

    double getMedian()
    {
        return k&1? smallHeap.top() : ((double) smallHeap.top() + largeHeap.top()) / 2.0;
    }
};
class Solution {
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        DualHeap dhp(k);
        vector<double> ans;
        for(int i=0; i<k; ++i)
        {
            dhp.insert(nums[i]);
        }
        ans.push_back(dhp.getMedian());
        for(int i=k; i<n; ++i)
        {
            dhp.insert(nums[i]);
            dhp.erase(nums[i-k]);
            ans.push_back(dhp.getMedian());
        }
        return ans;
    }
};
```

## 练习
1. [存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/solutions/)
```cpp
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {
        int n = nums.size();
        multiset<long> rec;
        for(int i=0; i<n; ++i)
        {
            auto iter = rec.lower_bound((long)nums[i]-valueDiff);
            if(iter!=rec.end() && *iter <= (long)nums[i]+valueDiff)
            {
                return true;
            }
            rec.insert(nums[i]);
            if(i>=indexDiff)
            {
                rec.erase(nums[i-indexDiff]);
            }
        }

        return false;;
    }
};
```

2. [K 个关闭的灯泡](https://leetcode.cn/problems/k-empty-slots/solutions/)
```cpp
class Solution {
public:
    int kEmptySlots(vector<int>& bulbs, int k) {
        int n = bulbs.size();
        set<int> rec;
        for(int i=0; i<n; ++i)
        {
            rec.insert(bulbs[i]);
            auto iter = rec.lower_bound(bulbs[i]);
            iter++;
            if(iter!=rec.end() && *iter==bulbs[i]+k+1)
            {
                return i+1;
            }
            iter--;
            if(iter!=rec.begin() && *(--iter)==bulbs[i]-k-1)
            {
                return i+1;
            }
        }

        return -1;
    }
};
```

3. [绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solutions/)
```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int n = nums.size();
        multiset<int> rec;
        int maxLen = 0;
        int l=0, r=0;

        while(r<n)
        {
            rec.insert(nums[r]);
            r++;
            while(*(--rec.end()) - *rec.begin() > limit)
            {
                rec.erase(rec.find(nums[l]));
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```

# 链表中的双指针问题
## 练习

1. [环形链表](https://leetcode.cn/problems/linked-list-cycle/solutions/)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;

        do
        {
            if(fast==nullptr || fast->next==nullptr)
            {
                return false;
            }
            slow = slow->next;
            fast = fast->next->next;

        }while(slow!=fast);

        return true;
    }
};
```

2. [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solutions/)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy(-1);
        dummy.next = head;
        ListNode* slow = &dummy;
        ListNode* fast = head;
        for(int i=0; i<n; ++i)
        {
            fast = fast->next;
        }

        while(fast!=nullptr)
        {
            slow = slow->next;
            fast = fast->next;
        }
        ListNode* toDelete = slow->next;
        slow->next = slow->next->next;
        delete toDelete;

        return slow==&dummy? slow->next : head;
    }
};
```
3. [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/solutions/)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode dummy(-1);
        dummy.next = head;
        ListNode* slow = &dummy;
        ListNode* fast = &dummy;

        while(fast!=nullptr)
        {
            slow = slow->next;
            fast = fast->next==nullptr? nullptr : fast->next->next;
        }

        return slow;
    }
};
```
4. [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* init = head;

        do
        {
            if(fast==nullptr || fast->next==nullptr)
            {
                return nullptr;
            }
            slow = slow->next;
            fast = fast->next->next;
        }while(slow!=fast);

        while(init!=slow)
        {
            init = init->next;
            slow = slow->next;
        }

        return init;
    }
};
```
5. [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* pa = headA;
        ListNode* pb = headB;

        while(pa!=pb)
        {
            pa = pa==nullptr? headB : pa->next;
            pb = pb==nullptr? headA : pb->next;
        }

        return pa;
    }
};
```