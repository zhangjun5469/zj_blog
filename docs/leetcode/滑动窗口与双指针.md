> 参考：[滑动窗口与双指针](https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/owiz0j/)

# 循环不变量
## 概念解析
循环不变量」不是很高深的概念，在「算法」和「数据结构」的世界里，到处都有它的身影。

「循环不变量」是指我们在编写代码的过程中，**要一直循序不变的性质**，这样的性质是根据要解决的问题，由我们自己定义的。「循环不变量」是我们写对一个问题的基础，保证了在「初始化」「循环遍历」「结束」这三个阶段相同的性质，使得一个问题能够被正确解决。

## 例题
1. [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solutions/)。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int j = 1;
        // 循环不变量： [0,j) 区间不包含重复元素
        for(int i=1; i<n; ++i)
        {
            if(nums[i]!=nums[j-1])
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```

2. [最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/)。
```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int l=0, r=1;
        int ans = 1;
        // 循环不变量：[l,r) 区间为连续递增子序列
        while(r<n)
        {
            if(nums[r]<=nums[r-1])
            {
                l=r;
            }
            r++;
            ans = max(ans, r-l);
        }
        return ans;
    }
};
```

## 练习
1. [移除元素](https://leetcode.cn/problems/remove-element/solutions/)。
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int j=0;
        // 循环不变量：[0,j) 不含有 val 元素
        for(int i=0; i<n; ++i)
        {
            if(nums[i]!=val)
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```
2. [删除排序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solutions/)。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n<=2)
        {
            return n;
        }
        int j = 2;
        // 循环不变量：[0,j) 不含有出现次数超过两次的元素
        for(int i=2; i<n; ++i)
        {
            if(nums[i]!=nums[j-1] || nums[i]!=nums[j-2])
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```
3. [移动零](https://leetcode.cn/problems/move-zeroes/solutions/)。
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int j = 0;
        // 循环不变量： [0,j) 区间不含有0元素
        for(int i=0; i<n; ++i)
        {
            if(nums[i]!=0)
            {
                swap(nums[j], nums[i]);
                j++;
            }
        }
    }
};
```

# 使用循环不变量写对代码
## 关键概念
我们在写代码的时候一定要明确自己对变量以及区间的定义是什么，并且在编写代码的过程中保持定义不变。

## 例题
1. [颜色分类](https://leetcode.cn/problems/sort-colors/solutions/)。
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int zero = 0;
        int two = n;
        int i=0;
        // 循环不变量：
        // [0,zero) 区间是0
        // [zero, i) 区间是1
        // [two, n) 区间是2
        // [i,two) 区间待扫描
        while(i<two)
        {
            if(nums[i]==0)
            {
                swap(nums[zero], nums[i]);
                zero++;
                i++;
            }
            else if(nums[i]==1)
            {
                i++;
            }
            else
            {
                two--;
                swap(nums[two], nums[i]);
            }
        }
    }
};
```
2. [数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/)
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        int wantIdx = n-k;
        int l=0, r=n-1;
        while(true)
        {
            int partitionIdx = partition(nums, l, r);
            if(partitionIdx==wantIdx)
            {
                return nums[wantIdx];
            }
            else if(partitionIdx>wantIdx)
            {
                r = partitionIdx -1;
            }
            else
            {
                l = partitionIdx +1;
            }
        }
    }

    int partition(vector<int>& nums, int l, int r)
    {
        int pivot = nums[r];
        int j = l;
        int i = l;
        // 循环不变量： [l,j) 区间元素都小于等于pivot
        while(i<r)
        {
            if(nums[i]<=pivot)
            {
                swap(nums[j], nums[i]);
                j++;
            }
            i++;
        }
        swap(nums[j], nums[r]);
        return j;
    }
};
```

# 滑动窗口 1：同向交替移动的两个变量
## 概念解析
有一类数组上的问题，问我们固定长度的滑动窗口的性质，这一类问题在思维层面上相对简单。我们通过两道简单的例题向大家展示这一类问题的写法。

## 例题
1. [子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/solutions/)
```cpp
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int n = nums.size();
        int windowSum = 0;
        for(int i=0; i<k; ++i)
        {
            windowSum += nums[i];
        }
        int maxSum = windowSum;
        for(int i=k; i<n; ++i)
        {
            windowSum += nums[i] - nums[i-k];
            maxSum = max(maxSum, windowSum);
        }

        return (double)maxSum / k;
    }
};
```


2. [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/solutions/)
```cpp
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int n = customers.size();
        int originalCount = 0;
        for(int i=0; i<n; ++i)
        {
            if(grumpy[i]==0)
            {
                originalCount += customers[i];
            }
        }
        int extraCount = 0;
        for(int i=0; i<minutes; ++i)
        {
            if(grumpy[i]==1)
            {
                extraCount += customers[i];
            }
        }
        int maxExtraCount = extraCount;
        for(int i=minutes; i<n; ++i)
        {
            extraCount += (grumpy[i]==1? customers[i]:0) - (grumpy[i-minutes]==1? customers[i-minutes]:0);
            maxExtraCount = max(maxExtraCount, extraCount);
        }

        return originalCount + maxExtraCount;
    }
};
```

## 练习

3. [可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/)
```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int total = accumulate(cardPoints.begin(), cardPoints.end(), 0);
        int newK = n-k;
        int windowSum = 0;
        for(int i=0; i<newK; ++i)
        {
            windowSum += cardPoints[i];
        }
        int minSum = windowSum;
        for(int i=newK; i<n; ++i)
        {
            windowSum += cardPoints[i] - cardPoints[i-newK];
            minSum = min(minSum, windowSum);
        }

        return total - minSum;
    }
};
```

2. [定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/)
```cpp
class Solution {
public:
    int maxVowels(string s, int k) {
        int n = s.size();
        int windowSum = 0;
        for(int i=0; i<k; ++i)
        {
            if(check(s[i]))
            {
                windowSum++;
            }
        }
        int maxSum = windowSum;
        for(int i=k; i<n; ++i)
        {
            windowSum += (check(s[i])? 1:0) - (check(s[i-k])? 1:0);
            maxSum = max(maxSum, windowSum);
        }

        return maxSum;
    }

    bool check(char& c)
    {
        return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';
    }
};
```

3. [将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solutions/)
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int n = nums.size();
        int target = accumulate(nums.begin(), nums.end(), 0) - x;
        if(target==0)
        {
            return n;
        }
        int windowSum = 0;
        int l=0, r=0;
        int maxLen = 0;
        while(r<n)
        {
            windowSum += nums[r];
            r++;
            while(l<r && windowSum>target)
            {
                windowSum -= nums[l];
                l++;
            }
            if(target==windowSum)
            {
                maxLen = max(maxLen, r-l);
            }
        }

        return maxLen==0? -1 : (n-maxLen);
    }
};
```

# 滑动窗口 2：不定长度的滑动窗口
## 概念解析
有一类数组上的问题，需要使用两个指针变量（我们称为左指针和右指针），同向、交替向右移动完成任务。这样的过程像极了一个窗口在平面上滑动的过程，因此我们将解决这一类问题的算法称为「滑动窗口」问题。

## 例题

1. [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/solutions/)
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        int sn = s.size();
        int tn = t.size();
        vector<int> pattern(128, 0);
        int distance = 0;
        for(auto& c: t)
        {
            pattern[c]++;
            if(pattern[c]==1)
            {
                distance++;
            }
        }
        vector<int> window(128, 0);
        int matches = 0;
        int l=0, r=0;
        int start = 0;
        int minLen = sn+1;
        while(r<sn)
        {
            char c = s[r];
            window[c]++;
            if(window[c]==pattern[c])
            {
                matches++;
            }
            r++;
            while(matches==distance)
            {
                if(minLen > r-l)
                {
                    start = l;
                    minLen = r-l;
                }
                char lc = s[l];
                window[lc]--;
                if(window[lc]<pattern[lc])
                {
                    matches--;
                }
                l++;
            }
        }

        return minLen==sn+1? "" : s.substr(start, minLen);
    }
};
```

2. [替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/)
```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        int n = s.size();
        vector<int> charCount(26, 0);
        int l=0, r=0;
        int maxCount = 0;
        int maxLen = 0;
        // 循环过程中不需要维护 maxCount的正确性，只需要保证 charCount的正确性即可，仔细思考下(因为我们想求的是最大长度)。
        while(r<n)
        {
            charCount[s[r]-'A']++;
            maxCount = max(maxCount, charCount[s[r]-'A']);
            r++;
            while(r-l > maxCount+k)
            {
                charCount[s[l]-'A']--;
                l++;
            }
            maxLen = max(maxLen, r-l);
        }

        return maxLen;
    }
};
```