> 参考：[滑动窗口与双指针](https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/owiz0j/)

# 循环不变量
## 概念解析
循环不变量」不是很高深的概念，在「算法」和「数据结构」的世界里，到处都有它的身影。

「循环不变量」是指我们在编写代码的过程中，**要一直循序不变的性质**，这样的性质是根据要解决的问题，由我们自己定义的。「循环不变量」是我们写对一个问题的基础，保证了在「初始化」「循环遍历」「结束」这三个阶段相同的性质，使得一个问题能够被正确解决。

## 例题
1. [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solutions/)。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int j = 1;
        // 循环不变量： [0,j) 区间不包含重复元素
        for(int i=1; i<n; ++i)
        {
            if(nums[i]!=nums[j-1])
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```

2. [最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/)。
```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int l=0, r=1;
        int ans = 1;
        // 循环不变量：[l,r) 区间为连续递增子序列
        while(r<n)
        {
            if(nums[r]<=nums[r-1])
            {
                l=r;
            }
            r++;
            ans = max(ans, r-l);
        }
        return ans;
    }
};
```

## 练习
1. [移除元素](https://leetcode.cn/problems/remove-element/solutions/)。
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int j=0;
        // 循环不变量：[0,j) 不含有 val 元素
        for(int i=0; i<n; ++i)
        {
            if(nums[i]!=val)
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```
2. [删除排序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solutions/)。
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n<=2)
        {
            return n;
        }
        int j = 2;
        // 循环不变量：[0,j) 不含有出现次数超过两次的元素
        for(int i=2; i<n; ++i)
        {
            if(nums[i]!=nums[j-1] || nums[i]!=nums[j-2])
            {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};
```
3. [移动零](https://leetcode.cn/problems/move-zeroes/solutions/)。
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int j = 0;
        // 循环不变量： [0,j) 区间不含有0元素
        for(int i=0; i<n; ++i)
        {
            if(nums[i]!=0)
            {
                swap(nums[j], nums[i]);
                j++;
            }
        }
    }
};
```

# 使用循环不变量写对代码
## 关键概念
我们在写代码的时候一定要明确自己对变量以及区间的定义是什么，并且在编写代码的过程中保持定义不变。

## 例题
1. [颜色分类](https://leetcode.cn/problems/sort-colors/solutions/)。
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int zero = 0;
        int two = n;
        int i=0;
        // 循环不变量：
        // [0,zero) 区间是0
        // [zero, i) 区间是1
        // [two, n) 区间是2
        // [i,two) 区间待扫描
        while(i<two)
        {
            if(nums[i]==0)
            {
                swap(nums[zero], nums[i]);
                zero++;
                i++;
            }
            else if(nums[i]==1)
            {
                i++;
            }
            else
            {
                two--;
                swap(nums[two], nums[i]);
            }
        }
    }
};
```
2. [数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/)
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        int wantIdx = n-k;
        int l=0, r=n-1;
        while(true)
        {
            int partitionIdx = partition(nums, l, r);
            if(partitionIdx==wantIdx)
            {
                return nums[wantIdx];
            }
            else if(partitionIdx>wantIdx)
            {
                r = partitionIdx -1;
            }
            else
            {
                l = partitionIdx +1;
            }
        }
    }

    int partition(vector<int>& nums, int l, int r)
    {
        int pivot = nums[r];
        int j = l;
        int i = l;
        // 循环不变量： [l,j) 区间元素都小于等于pivot
        while(i<r)
        {
            if(nums[i]<=pivot)
            {
                swap(nums[j], nums[i]);
                j++;
            }
            i++;
        }
        swap(nums[j], nums[r]);
        return j;
    }
};
```